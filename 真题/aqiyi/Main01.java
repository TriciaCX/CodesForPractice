package enterprise.aqiyi;

import java.util.Scanner;


/**
 * 排列计数
 * 给定一个长度为N-1，且只包含0和1的序列A1到An-1，如果一个1到N的排列P1到Pn满足对于1<=i<N，当Ai=0时，pi<pi+1；当Ai=1时，pi>pi+1,则称该排列符合要求
 * 求共有多少个符合要求的排列
 * 要求对输出取模
 */
//以DID（降增降为例）
//dp[i][j] 表示由 i+1 个数字组成且第 i+1 个数字（即序列中的最后一个数字）是剩余数字中（包括当前数字）中第 j+1 小的数字。
// 比如 dp[0][0]，表示序列只有1个数字，且该数字是剩余数字中最小的，那就只能是0。
// 再比如，dp[1][2] 表示该序列有两个数字，且第二个数字是剩余数字中第三小的，那么序列只能是 32，因为剩余数字为 0，1，2（包括最后一个数字），这里2就是第三小的。
// 有些情况序列不唯一，比如 dp[1][1] 表示该序列有两个数字，且第二个数字是剩余数字中第二小的，此时的序列就有 31（1是 0，1，2 中第二小的）和 21（1是 0，1，3 中第二小的）两种情况。
            /*搞清楚了 dp 的定义之后，再来推导状态转移方程吧，
         1---   对于 dp[0][j] 的情况，十分好判断，因为只有一个数字，并不存在升序降序的问题，所以 dp[0][j] 可以都初始化为1
            dp[0][3] = 1  (3)
            dp[0][2] = 1  (2)
            dp[0][1] = 1  (1)
            dp[0][0] = 1  (0)
         2---  然后需要加第二个数字，由于需要降序，那么根据之前的分析，新加的数字不可能是第四小的，所以不可能出现 dp[1][3] 为正数，
               因为这表示有两个数字，且第二个数字是剩余数字中的第四小，总共就四个数字，第四小的数字就是最大数字，由于是降序，所以第二个数字要小于第一个数字，这里就矛盾了，
               所以 dp[1][3] 一定为0，而其余的确实可以从上一层递推过来，
               具体来说，对于 dp[1][j]，需要累加 dp[0][k] ( j < k <= n-1 )：
            dp[1][2] = dp[0][3] = 1  (32)
            dp[1][1] = dp[0][3] + dp[0][2] = 2  (31, 21)
            dp[1][0] = dp[0][3] + dp[0][2] + dp[0][1] = 3  (30, 20, 10)

         3--   然后需要加第三个数字，由于需要升序，那么根据之前的分析，此时已经有两个数字了，新加的第三个数字只可能是剩余数字的第一小和第二小，
               即只有 dp[2][0] 和 dp[2][1] 会有值，跟上面相似，其也是由上一层累加而来，对于 dp[2][j]，需要累加 dp[1][k] ( 0 <= k <= j ):
            dp[2][1] = dp[1][1] + dp[1][0] = 5  (312, 213, 302, 203, 103)
            dp[2][0] = dp[1][0] = 3  (301, 201, 102)

         4--  最后再加第四个数字，由于需要降序，那么根据之前的分析，此时已经有三个数字了，新加的第四个数字只可能是剩余数字的第一小，即只有 dp[3][0] 会有值，
              跟上面相似，其也是由上一层累加而来，对于 dp[3][j]，需要累加 dp[2][k] ( j< k <= n-1 )，这里有值的只有 dp[2][1]：
            dp[3][0] = dp[2][1] = 5 (3120, 2130, 3021, 2031, 1032)

            这种方法算出的 dp 数组为：
            1 1 1 1
            3 2 1 0
            3 5 0 0
            5 0 0 0
             */

public class Main01 {
    //leetcode903
    final  static int MOD = (int)1e9+7;
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] A = new int[n-1];
        for(int i=0;i<n-1;i++){
            A[i] = scanner.nextInt();
        }

        int[][] dp = new int[n][n];
        //do[i][j]
        for(int i=0;i<n;i++){
            dp[0][i] = 1; //1个数，只有一种情况
        }
        for(int i=0;i<n-1;i++){
            if(A[i]==1){ //第i+1个数比第i个数小
                 for(int j=0,tmp = 0;j<n-i-1;j++){
                     tmp = (tmp+dp[i][j])%MOD;
                     dp[i+1][j] = tmp;
                 }
            }
            else if(A[i]==0){//第i+1个数比第i个数大
                for(int j=n-1-i-1,tmp=0;j>=0;j--){
                    tmp = (tmp+dp[i][j+1])%MOD;
                    dp[i+1][j] = tmp;
                }
            }
        }
        System.out.println(dp[n-1][0]);

    }
}
