package interviewTop100;

public class leetcode191
{
/**
 * leetcode 191
 * 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。
 */
	
	/**
	 * 方法1：循环和位移动
	 * 这个方法比较直接。我们遍历数字的 32 位。如果某一位是 1 ，将计数器加一。
	 * 我们使用 位掩码 来检查数字的第 i^{th}ith 位。一开始，掩码 m=1因为 1 的二进制表示是
0000 0000 0000 0000 0000 0000 0000 0001
显然，任何数字跟掩码 11 进行逻辑与运算，都可以让我们获得这个数字的最低位。检查下一位时，我们将掩码左移一位。
0000 0000 0000 0000 0000 0000 0000 0010
并重复此过程。
	 */
	public int hammingWeight(int n) {
		int bits = 0;
	    int mask = 1;   //掩码
	    for (int i = 0; i < 32; i++) {
	        if ((n & mask) != 0) {
	            bits++;
	        }
	        mask <<= 1;  //左移  c<<=2 就是 c=c<<2 把c左移2位得到的值 给 c 
	    }
	    return bits;
	}
	
	/**
	 * 方法2：位移动的小技巧
	 * 我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 1反转，并把答案加一。
	 * 当数字变成 0的时候偶，我们就知道它没有 1的位了，此时返回答案。
	 * 这里关键的想法是对于任意数字 n ，将 n 和 n - 1 做与运算，会把最后一个 1 的位变成 0 。
	 * 为什么？考虑 n 和 n - 1的二进制表示。
	 */
	public int hammingWeightII(int n) {
	    int sum = 0;
	    while (n != 0) {
	        sum++;
	        n &= (n - 1);
	    }
	    return sum;
	}

}
